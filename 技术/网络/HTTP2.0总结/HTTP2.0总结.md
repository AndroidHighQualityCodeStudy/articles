<a name="index">**目录**</a>

- <a href="#ch1">**1 HTTP2.0的设计目标**</a>

<br>
<br>

### <a name="ch1">1 HTTP2.0的设计目标</a><a style="float:right;text-decoration:none;" href="#index">[Top]</a>

HTTP2.0 的前身是由谷歌主导的 SPDY 协议，针对 HTTP1.x 的问题，SPDY 在立项之初设定了如下几个技术目标：

- 减少 50% 的页面加载时间（PLT）。

- 避免让 web 站点的所有者修改任何 web 上内容。

- 最小化新协议的部署成本，避免对网络架构进行修改。

- 开源。

- 采集真实网络的性能数据来不断修正协议。

总结其核心的目标其实就两个：

1. 加速。

2. 一键加速。

加速，意味着要比 HTTP1.x 更快；一键加速，意味着可以在不修改上层应用和网络框架的基础上简单快速地部署。这说明，SPDY/HTTP2.0 是对 HTTP1.x 的演进和扩展，而不是直接替换。如果把 HTTP 协议看做是面向对象编程，那么 SPDY/HTTP2.0 只扩展了一个子类，对于应用层来说，接口不变；如果把 HTTP 看做是操作系统，那么 SPDY/HTTP2.0 只是修改内核实现，而不改变系统调用接口。这样，我们可以像热插拔一样升级协议，而不用修改上层业务和框架，HTTP 对性能的提升对于上层来说都是透明的。

>>这里说的 HTTP 的接口指的是 HTTP 的通用语义，比如 HTTP 方法名、状态码、URI规范、头部字段等，这些对于业务层代码可见的特征。

SPDY 一开始只是作为一个实验性项目进行测试，同时也被很多三方应用到，在得到广泛认可后，将其核心的最有用的优化部分集成到了 HTTP2.0 中。后续 SPDY 和 HTTP2.0 并行研发，且 HTTP2.0 成为了后续的重点优化项目，而 SPDY 更多地充当了 HTTP2.0 的灰度版本，持续地在真实网络环境中验证各种优化手段，对验证成功的部分则集成到 HTTP2.0 中，所以，现在HTTP2.0 已经成为了最终稳定的 HTTP 未来版本了。

<br>
<br>

### <a name="ch2">2 HTTP2.0的核心组成</a><a style="float:right;text-decoration:none;" href="#index">[Top]</a>

HTTP2.0 在保持 HTTP 通用语义不变的前提下，针对 HTTP1.x 的问题进行了一系列的底层改进。根据上一节的描述我们不难推断，HTTP1.x 现存的最大问题就是——慢！具体体现在：

- 一个 TCP 连接只承载一个 HTTP 请求/响应。这样并发请求需要建立多个连接，这样带来的问题有两个：一是连接的建立比较耗时，连接数越多越耗时；二是服务方在排队处理并发连接的时候，可能出现前面的连接处理太耗时，导致后面的连接进行空等，造成队头阻塞问题。针对这个问题，有人提出了连接复用方案，即创建连接缓存池，连接池里面的连接被回收前都不会关闭，可以重复用来处理更多的 HTTP 消息，但是一个 HTTP 消息不管多大都要占用一条连接，对网络带宽的利用是不够的，这直接影响了吞吐量并使得总体网络传输效率变慢。

- 多个请求的处理是随机的，一个紧迫的请求并不会因为其更重要而更容易被服务器优先处理。

- HTTP 头部字段是纯文本的，且相同的重复的头部文本在大量的消息里进行传输，对带宽是一种很大的浪费。

- 没有服务器推送功能。

前三个缺点在互联网刚刚开始兴起的时候显得还不是特别突出，但是随着网络规模的日益扩大，流量暴涨，这些问题越来越成为了束缚网络体验的关键问题。所以，对以上几个问题的解决就成为了 HTTP2.0 的核心组成部分，即：

- 数据格式的优化——二进制、帧、消息、流。

- TCP连接多路复用。

- 数据流优先级处理。

- 流量控制。

- 服务器推送。

- 头部压缩技术。

下面分别介绍。

<br>
<br>

### <a name="ch3">3 数据格式的优化——二进制、帧、消息、流</a><a style="float:right;text-decoration:none;" href="#index">[Top]</a>


















































