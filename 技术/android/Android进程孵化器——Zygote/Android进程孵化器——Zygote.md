<a name="index">**目录**</a>

- <a href="#ch1">**1 一个 Android 进程都有啥**</a>

<br>
<br>

### <a name="ch1">1 一个 Android 进程都有啥</a><a style="float:right;text-decoration:none;" href="#index">[Top]</a>

众所周知，Android 是基于 Linux 内核的，所以一个 Android 进程其本质也是一个 Linux 进程。Android 进程拥有 Linux 进程所有的一切，包括：进程 ID，所有者，进程状态，程序计数器，调度信息、内存指针等，因为在 Linux 下，绝大部分进程都是由一个祖先进程 fork 而来。除此以外，在 Android 进程的内存空间中还运行着如下特定的资源和程序：

- 运行 Java 字节码的虚拟机（Dalvik or ART）。
- 所需的各种 Java 类，包括各种系统组件类（Activity，Service 等等）。
- framework 资源文件，比如各种系统主题，系统 res 资源等。
- 图形处理相关库，如 OpenGL。
- 其它共享库。
- 文本库，如字体文件等。
- 其它相关资源（与 Android 系统版本演进有关）。

每当我们启动一个新的 Android 进程，比如一个新的 APP，以上这些资源和程序都是新进程运行所必须的。一种直接简单的方案就是每次启动新进程后，将这些资源都重新加载一遍，这样各个进程之间都是彻底隔离的，安全性得到保障。但是我们知道，即便是一个普通的 Linux 进程的生成也不是将所有资源重新拷贝一份的，因为这既耗时、也浪费内存空间。

我们知道，在 Linux 中，新进程的生成是遵循 `copy on write` 原则的。即，所有的子进程与父进程默认都共享所有资源，父进程 fork 一个子进程之后，子进程只需要生成共享资源的引用即可。只有当子进程需要对某个资源进行写入时，才需要拷贝一份原资源，从而保证资源的独立性。这样的原则既保证共享资源的访问安全，又能实现进程的快速生成，同时也节省内存空间。因为，对于大部分进程而言，有太多的共享资源仅仅是只读而已。

基于以上的分析，一个 Android 进程同样也需要遵循 `copy on write` 原则。所以，我们必须为所有的 Android 进程先生成一个共同的祖先进程，这个祖先进程首先是一个普通的 Linux 进程，然后在此基础上加载 Android 进程运行所需的所有特定资源和程序。这样每当需要生成一个新的 Android 进程时，比如启动一个新的 APP 时，就只需要从这个共同的 Android 祖先进程 fork 出来，然后运行新进程的入口程序（main 函数）即可。

这样一个 Android 祖先进程就如同所有 Android 子进程的母体一样，不停地孵化出新的 Android 子进程，它有一个形象的名字——Zygote！




































































